import logging
import asyncio
import time
import os
from collections import defaultdict
from aiohttp import web
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters,
    CallbackQueryHandler
)
from enhanced_ai_handler import enhanced_ai_handler
from database import user_db
from smart_features import smart_features
from config import TELEGRAM_TOKEN, CREATOR_USERNAME, TELEGRAM_CHANNEL, WEBSITE_URL

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)




def format_code_for_telegram(text):
    """Format code blocks and basic Markdown for Telegram HTML output."""
    import re

    block_placeholders = {}
    inline_placeholders = {}

    def replace_code_block(match):
        code_content = match.group(2).rstrip()
        escaped_code = escape_code_content(code_content)
        placeholder = f'__CODE_BLOCK_{len(block_placeholders)}__'
        block_placeholders[placeholder] = f'<pre>{escaped_code}</pre>'
        return placeholder

    text = re.sub(r'```(\w+)?\n?(.*?)\n?```', replace_code_block, text, flags=re.DOTALL)

    def replace_inline_code(match):
        code_content = escape_code_content(match.group(1))
        placeholder = f'__INLINE_CODE_{len(inline_placeholders)}__'
        inline_placeholders[placeholder] = f'<code>{code_content}</code>'
        return placeholder

    text = re.sub(r'`([^`\n]+)`', replace_inline_code, text)

    text = escape_html_chars(text)
    text = convert_markdown_to_html(text)

    for placeholder, value in inline_placeholders.items():
        text = text.replace(placeholder, value)

    for placeholder, value in block_placeholders.items():
        text = text.replace(placeholder, value)

    return f"‚úÖ <b>–û—Ç–≤–µ—Ç:</b>\n{text}"


def escape_code_content(code_text):
    """Escape HTML in code content while preserving structure"""
    code_text = code_text.replace('&', '&amp;')
    code_text = code_text.replace('<', '&lt;')
    code_text = code_text.replace('>', '&gt;')
    return code_text.strip()


def escape_html_chars(text):
    """Escape HTML special characters for safe Telegram HTML parsing"""
    text = text.replace('&', '&amp;')
    text = text.replace('<', '&lt;')
    text = text.replace('>', '&gt;')
    text = text.replace('"', '&quot;')
    return text


def convert_markdown_to_html(text: str) -> str:
    import re

    # Bold (**text**)
    text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)
    # Italic (*text*)
    text = re.sub(r'(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)', r'<i>\1</i>', text)
    # Bullet points starting with '-', '*', or '?'
    text = re.sub(r'(^|\n)[\-*?]\s+', r'\1? ', text)
    return text


class RateLimiter:
    def __init__(self):
        self.user_requests = defaultdict(list)
        self.max_requests = 10  # requests per minute

    def is_allowed(self, user_id: int) -> bool:
        now = time.time()
        # Clean old requests
        self.user_requests[user_id] = [
            req_time for req_time in self.user_requests[user_id]
            if now - req_time < 60
        ]

        if len(self.user_requests[user_id]) >= self.max_requests:
            return False

        self.user_requests[user_id].append(now)
        return True


class ResponseCache:
    def __init__(self):
        self.cache = {}
        self.max_size = 100

    def get(self, question_hash: str):
        return self.cache.get(question_hash)

    def set(self, question_hash: str, response: str):
        if len(self.cache) >= self.max_size:
            # Remove oldest entry
            oldest_key = next(iter(self.cache))
            del self.cache[oldest_key]
        self.cache[question_hash] = response



def _is_legacy_fallback_response(text: str) -> bool:
    if not text:
        return False
    markers = ("Hello, world", "–í–æ–ø—Ä–æ—Å –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é", "–ë—ã—Å—Ç—Ä—ã–π –æ—Ç–≤–µ—Ç –∏–∑ –∫—ç—à–∞")
    text_lower = text.lower()
    return any(marker.lower() in text_lower for marker in markers)
# –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
class UserContext:
    def __init__(self):
        self.skill_level = "beginner"
        self.preferred_language = "russian"
        self.history = []
        self.preferences = {
            'code_style': 'detailed',  # detailed, concise, beginner
            'explanation_level': 'medium',  # basic, medium, advanced
            'favorite_languages': [],
            'learning_goals': []
        }
        self.last_tip_topic = None
        self.last_tip_text = None
        self.user_id = None
        self.feedback_scores = []

    def add_message(self, role: str, content: str):
        self.history.append({"role": role, "content": content, "timestamp": time.time()})
        if len(self.history) > 10:  # Increased history size
            self.history.pop(0)

    def get_recent_context(self, n: int):
        return self.history[-n:] if len(self.history) >= n else self.history

    def update_skill_level(self, feedback_score: int):
        self.feedback_scores.append(feedback_score)
        if len(self.feedback_scores) > 5:
            self.feedback_scores.pop(0)

        avg_score = sum(self.feedback_scores) / len(self.feedback_scores)
        if avg_score >= 4:
            self.skill_level = "advanced"
        elif avg_score >= 3:
            self.skill_level = "intermediate"
        else:
            self.skill_level = "beginner"


# –•—Ä–∞–Ω–∏–ª–∏—â–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
user_contexts = {}


def get_user_context(user_id: int) -> UserContext:
    if user_id not in user_contexts:
        user_contexts[user_id] = UserContext()
    context = user_contexts[user_id]
    context.user_id = user_id
    return context


def get_main_keyboard():
    keyboard = [
        [InlineKeyboardButton("üë®‚Äçüíª –°–≤—è–∑–∞—Ç—å—Å—è —Å —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º", url=f"tg://resolve?domain={CREATOR_USERNAME[1:]}")],
        [InlineKeyboardButton("üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url=TELEGRAM_CHANNEL)],
        [InlineKeyboardButton("üåê –ü–æ—Å–µ—Ç–∏—Ç—å —Å–∞–π—Ç", url=WEBSITE_URL)]
    ]
    return InlineKeyboardMarkup(keyboard)


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    user_context = get_user_context(user_id)

    if query.data == "feedback_good":
        user_context.update_skill_level(5)
        await query.edit_message_reply_markup(reply_markup=None)
        await query.message.reply_text(
            "üôè –°–ø–∞—Å–∏–±–æ –∑–∞ –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å! –≠—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç –º–Ω–µ —Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è –ª—É—á—à–µ.\n"
            "üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞: –ß–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–µ–µ –≤–∞—à–∏ –≤–æ–ø—Ä–æ—Å—ã, —Ç–µ–º —Ç–æ—á–Ω–µ–µ –º–æ–∏ –æ—Ç–≤–µ—Ç—ã!"
        )

    elif query.data == "feedback_bad":
        user_context.update_skill_level(2)
        await query.edit_message_reply_markup(reply_markup=None)
        await query.message.reply_text(
            "üòî –ò–∑–≤–∏–Ω–∏—Ç–µ, —á—Ç–æ –Ω–µ —Å–º–æ–≥ –ø–æ–º–æ—á—å.\n"
            "üí¨ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
            "‚Ä¢ –ü–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å\n"
            "‚Ä¢ –î–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n"
            "‚Ä¢ –†–∞–∑–±–∏—Ç—å —Å–ª–æ–∂–Ω—É—é –∑–∞–¥–∞—á—É –Ω–∞ —á–∞—Å—Ç–∏\n\n"
            "–Ø —É—á—É—Å—å –Ω–∞ –≤–∞—à–∏—Ö –æ—Ç–∑—ã–≤–∞—Ö!"
        )

    elif query.data == "get_hint":
        hints = [
            "üí° –î–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–¥–∞ –ø—Ä–∏–ª–æ–∂–∏—Ç–µ —Ñ–∞–π–ª –∏–ª–∏ –≤—Å—Ç–∞–≤—å—Ç–µ –∫–æ–¥ –≤ —Å–æ–æ–±—â–µ–Ω–∏–µ",
            "üîç –û–ø–∏—à–∏—Ç–µ, —á—Ç–æ –∏–º–µ–Ω–Ω–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç - —ç—Ç–æ –ø–æ–º–æ–∂–µ—Ç –Ω–∞–π—Ç–∏ –æ—à–∏–±–∫—É –±—ã—Å—Ç—Ä–µ–µ",
            "üìù –£–∫–∞–∂–∏—Ç–µ —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω—ã—Ö —Å–æ–≤–µ—Ç–æ–≤",
            "üéØ –ó–∞–¥–∞–≤–∞–π—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –≤–º–µ—Å—Ç–æ –æ–±—â–∏—Ö",
            "‚ö° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /stats —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–≤–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å"
        ]
        import random
        hint = random.choice(hints)
        await query.message.reply_text(hint)

    elif query.data == "learning_mode":
        learning_text = (
            "üìö –†–µ–∂–∏–º –æ–±—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!\n\n"
            "üéì –ß—Ç–æ –∏–∑—É—á–∞–µ–º —Å–µ–≥–æ–¥–Ω—è?\n"
            "‚Ä¢ –ù–∞–ø–∏—à–∏—Ç–µ '–æ—Å–Ω–æ–≤—ã python' –¥–ª—è –±–∞–∑–æ–≤–æ–≥–æ –∫—É—Ä—Å–∞\n"
            "‚Ä¢ –ù–∞–ø–∏—à–∏—Ç–µ 'javascript –¥–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö'\n"
            "‚Ä¢ –ù–∞–ø–∏—à–∏—Ç–µ '–∞–ª–≥–æ—Ä–∏—Ç–º—ã –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö'\n"
            "‚Ä¢ –ò–ª–∏ –∑–∞–¥–∞–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è\n\n"
            "üí™ –Ø –∞–¥–∞–ø—Ç–∏—Ä—É—é –æ–±—ä—è—Å–Ω–µ–Ω–∏—è –ø–æ–¥ –≤–∞—à —É—Ä–æ–≤–µ–Ω—å!"
        )
        await query.message.reply_text(learning_text)


# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "Unknown"

    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    user_data = user_db.get_user(user_id)
    user_db.update_user(user_id, {
        'username': username,
        'first_name': update.message.from_user.first_name or "Unknown"
    })

    logger.info(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} ({user_id}) –∑–∞–ø—É—Å—Ç–∏–ª –±–æ—Ç–∞")

    welcome_text = (
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –ü–æ–º–æ—â–Ω–∏–∫ –ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞\n"
        "üöÄ –°–æ–∑–¥–∞–Ω –í–∞–¥–∏–º–æ–º (vadzim.by)\n\n"
        "üíª –ü–æ–º–æ–≥—É —Å:\n"
        "‚Ä¢ –ê–Ω–∞–ª–∏–∑–æ–º –∏ –æ—Ç–ª–∞–¥–∫–æ–π –∫–æ–¥–∞\n"
        "‚Ä¢ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ–º –∫–æ–Ω—Ü–µ–ø—Ü–∏–π –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è\n"
        "‚Ä¢ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π\n"
        "‚Ä¢ –†–µ—à–µ–Ω–∏–µ–º –ø—Ä–æ–±–ª–µ–º –∏ –æ—à–∏–±–æ–∫\n"
        "‚Ä¢ –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–º –æ–±—É—á–µ–Ω–∏–µ–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é\n\n"
        "üéØ –Ø –∞–¥–∞–ø—Ç–∏—Ä—É—é—Å—å –ø–æ–¥ –≤–∞—à —É—Ä–æ–≤–µ–Ω—å –∏ —Å—Ç–∏–ª—å –æ–±—É—á–µ–Ω–∏—è!\n"
        "üìä –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏ - —ç—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç –º–Ω–µ —Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è –ª—É—á—à–µ\n\n"
        "üìù –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∫–æ–¥!\n\n"
        "‚ö° –ë—ã—Å—Ç—Ä—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/help - –ü–æ–ª—É—á–∏—Ç—å —Å–ø—Ä–∞–≤–∫—É\n"
        "/settings - –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è\n"
        "/about - –û —Å–æ–∑–¥–∞—Ç–µ–ª–µ\n\n"
        "üëá –¢–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂–µ:"
    )

    await update.message.reply_text(
        welcome_text,
        reply_markup=get_main_keyboard()
    )


async def settings_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_context = get_user_context(user_id)

    settings_text = (
        f"‚öôÔ∏è –í–∞—à–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:\n\n"
        f"üéØ –£—Ä–æ–≤–µ–Ω—å: {user_context.skill_level}\n"
        f"üìù –°—Ç–∏–ª—å –∫–æ–¥–∞: {user_context.preferences['code_style']}\n"
        f"üìñ –£—Ä–æ–≤–µ–Ω—å –æ–±—ä—è—Å–Ω–µ–Ω–∏–π: {user_context.preferences['explanation_level']}\n\n"
        "–î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞–ø–∏—à–∏—Ç–µ:\n"
        "‚Ä¢ '—É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –Ω–∞—á–∏–Ω–∞—é—â–∏–π/—Å—Ä–µ–¥–Ω–∏–π/–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π'\n"
        "‚Ä¢ '—Å—Ç–∏–ª—å –∫–æ–¥–∞ –∫—Ä–∞—Ç–∫–∏–π/–ø–æ–¥—Ä–æ–±–Ω—ã–π/–¥–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö'\n"
        "‚Ä¢ '–æ–±—ä—è—Å–Ω–µ–Ω–∏—è –±–∞–∑–æ–≤—ã–µ/—Å—Ä–µ–¥–Ω–∏–µ/–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ'"
    )

    await update.message.reply_text(settings_text, reply_markup=get_main_keyboard())


# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.message.from_user.id
        user_context = get_user_context(user_id)

        if not rate_limiter.is_allowed(user_id):
            await update.message.reply_text(
                "‚è±Ô∏è –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤! –ü–æ–¥–æ–∂–¥–∏—Ç–µ –º–∏–Ω—É—Ç—É.\n"
                "üí° –≠—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç –º–Ω–µ –ª—É—á—à–µ –æ–±—Å–ª—É–∂–∏–≤–∞—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
                reply_markup=get_main_keyboard()
            )
            return

        text = update.message.text

        if not text or len(text.strip()) == 0:
            await update.message.reply_text(
                "ü§î –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∫–æ–¥.",
                reply_markup=get_main_keyboard()
            )
            return

        # Handle encoding issues and special characters
        try:
            # Normalize text to handle emojis and special characters
            text = text.encode('utf-8', errors='ignore').decode('utf-8')
            if len(text) > 4000:  # Telegram message limit
                text = text[:4000] + "..."
        except Exception as encoding_error:
            logger.warning(f"Encoding issue for user {user_id}: {encoding_error}")
            await update.message.reply_text(
                "‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å.",
                reply_markup=get_main_keyboard()
            )
            return

        text_lower = text.lower()
        if '—É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å' in text_lower:
            if '–Ω–∞—á–∏–Ω–∞—é—â–∏–π' in text_lower:
                user_context.skill_level = 'beginner'
                await update.message.reply_text("‚úÖ –£—Ä–æ–≤–µ–Ω—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: –Ω–∞—á–∏–Ω–∞—é—â–∏–π")
            elif '—Å—Ä–µ–¥–Ω–∏–π' in text_lower or '–ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π' in text_lower:
                user_context.skill_level = 'intermediate'
                await update.message.reply_text("‚úÖ –£—Ä–æ–≤–µ–Ω—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: —Å—Ä–µ–¥–Ω–∏–π")
            elif '–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π' in text_lower:
                user_context.skill_level = 'advanced'
                await update.message.reply_text("‚úÖ –£—Ä–æ–≤–µ–Ω—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π")
            return

        if '—Å—Ç–∏–ª—å –∫–æ–¥–∞' in text_lower:
            if '–∫—Ä–∞—Ç–∫–∏–π' in text_lower:
                user_context.preferences['code_style'] = 'concise'
                await update.message.reply_text("‚úÖ –°—Ç–∏–ª—å –∫–æ–¥–∞: –∫—Ä–∞—Ç–∫–∏–π")
            elif '–ø–æ–¥—Ä–æ–±–Ω—ã–π' in text_lower:
                user_context.preferences['code_style'] = 'detailed'
                await update.message.reply_text("‚úÖ –°—Ç–∏–ª—å –∫–æ–¥–∞: –ø–æ–¥—Ä–æ–±–Ω—ã–π")
            elif '–Ω–∞—á–∏–Ω–∞—é—â–∏—Ö' in text_lower:
                user_context.preferences['code_style'] = 'beginner'
                await update.message.reply_text("‚úÖ –°—Ç–∏–ª—å –∫–æ–¥–∞: –¥–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö")
            return

        sensitive_keywords = [
            '–ø–∞—Ä–æ–ª—å', '—Ç–æ–∫–µ–Ω', '–∫–ª—é—á', 'password', 'token', 'key', 'api_key',
            'secret', '—Å–µ–∫—Ä–µ—Ç', '–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è', 'config', 'env', '.env'
        ]

        if any(keyword in text_lower for keyword in sensitive_keywords):
            await update.message.reply_text(
                "üîí –Ø –Ω–µ –º–æ–≥—É –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n\n"
                "–î–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤—Å–µ –ø–∞—Ä–æ–ª–∏ –∏ —Ç–æ–∫–µ–Ω—ã –∑–∞—â–∏—â–µ–Ω—ã.\n"
                "–ï—Å–ª–∏ –Ω—É–∂–Ω–∞ –ø–æ–º–æ—â—å —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏, –æ–ø–∏—à–∏—Ç–µ –∑–∞–¥–∞—á—É –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.",
                reply_markup=get_main_keyboard()
            )
            return

        import hashlib
        question_hash = hashlib.md5(text.encode()).hexdigest()
        cached_response = response_cache.get(question_hash)

        if cached_response and _is_legacy_fallback_response(cached_response):
            logger.info("Removing legacy fallback from cache")
            response_cache.cache.pop(question_hash, None)
            cached_response = None

        if cached_response:
            logger.info(f"üì¶ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –¥–ª—è {user_id}")
            await update.message.reply_text(
                cached_response + "\n\nüí° –ë—ã—Å—Ç—Ä—ã–π –æ—Ç–≤–µ—Ç –∏–∑ –∫—ç—à–∞!",
                reply_markup=get_main_keyboard()
            )
            return

        # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –≤–æ–ø—Ä–æ—Å–æ–≤
        user_db.increment_questions(user_id)

        if any(word in text_lower for word in ['javascript', 'js', '–¥–∂–∞–≤–∞—Å–∫—Ä–∏–ø—Ç']):
            user_db.add_topic_interest(user_id, 'javascript')
            if 'javascript' not in user_context.preferences['favorite_languages']:
                user_context.preferences['favorite_languages'].append('javascript')
        elif any(word in text_lower for word in ['python', '–ø–∏—Ç–æ–Ω', '–ø–∞–π—Ç–æ–Ω']):
            user_db.add_topic_interest(user_id, 'python')
            if 'python' not in user_context.preferences['favorite_languages']:
                user_context.preferences['favorite_languages'].append('python')
        elif any(word in text_lower for word in ['–Ω–∞–π–¥–∏ –æ—à–∏–±–∫—É', '–æ—à–∏–±–∫–∞', 'debug']):
            user_db.add_topic_interest(user_id, 'debugging')
        elif any(word in text_lower for word in ['—Å —á–µ–≥–æ –Ω–∞—á–∞—Ç—å', '–Ω–∞—á–∞—Ç—å —É—á–∏—Ç—å', '–æ—Å–Ω–æ–≤—ã']):
            user_db.add_topic_interest(user_id, 'learning')
            if 'learning_basics' not in user_context.preferences['learning_goals']:
                user_context.preferences['learning_goals'].append('learning_basics')

        user_context.add_message("user", text)

        # –õ–æ–≥–∏—Ä—É–µ–º –≤—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        logger.info(f"üì® –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {user_id}: {text[:100]}...")

        is_fallback = False
        try:
            response, is_fallback = await asyncio.wait_for(
                enhanced_ai_handler.get_specialized_response(
                    text,
                    "general",
                    user_context,
                    skill_level=user_context.skill_level,
                    preferences=user_context.preferences
                ),
                timeout=30.0
            )
        except asyncio.TimeoutError:
            logger.error(f"Timeout for user {user_id}")
            await update.message.reply_text(
                "‚è±Ô∏è –ó–∞–ø—Ä–æ—Å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–ø—Ä–æ—Å—Ç–∏—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–∑–∂–µ.",
                reply_markup=get_main_keyboard()
            )
            return
        except Exception as ai_error:
            logger.error(f"AI handler error for user {user_id}: {ai_error}")
            await update.message.reply_text(
                "ü§ñ –í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –ò–ò. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å.",
                reply_markup=get_main_keyboard()
            )
            return

        if not response or len(response.strip()) == 0:
            await update.message.reply_text(
                "ü§î –ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å.",
                reply_markup=get_main_keyboard()
            )
            return

        if not is_fallback:
            response_cache.set(question_hash, response)
        else:
            logger.info("Skipping cache for fallback response")

        user_context.add_message("assistant", response)

        # –õ–æ–≥–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
        logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç: {response[:100]}...")

        try:
            has_code = any([
                '\`\`\`' in response,  # Fixed: removed escaping from backticks
                '`' in response,  # Inline code
                'def ' in response,
                'function ' in response,
                'class ' in response,
                'import ' in response,
                'from ' in response,
                'console.log' in response,
                'print(' in response,
                'return ' in response,
                'html>' in response.lower(),
                'DOCTYPE' in response
            ])

            if has_code:
                formatted_response = format_code_for_telegram(response)
                await update.message.reply_text(
                    formatted_response,
                    reply_markup=get_main_keyboard(),
                    parse_mode='HTML'
                )
            else:
                safe_response = escape_html_chars(response)
                await update.message.reply_text(
                    f"‚úÖ <b>–û—Ç–≤–µ—Ç:</b>\n{safe_response}",
                    reply_markup=get_main_keyboard(),
                    parse_mode='HTML'
                )

        except Exception as send_error:
            logger.error(f"Message sending error: {send_error}")
            try:
                safe_response = escape_html_chars(response)
                await update.message.reply_text(
                    f"‚úÖ <b>–û—Ç–≤–µ—Ç:</b>\n{safe_response}",
                    reply_markup=get_main_keyboard(),
                    parse_mode='HTML'
                )
            except Exception:
                # Final fallback - guaranteed to work
                clean_response = ''.join(c for c in response if ord(c) < 128)  # ASCII only
                await update.message.reply_text(
                    f"‚úÖ –û—Ç–≤–µ—Ç: {clean_response[:1000]}",
                    reply_markup=get_main_keyboard()
                )

    except Exception as e:
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ handle_message –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        try:
            await update.message.reply_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ù–∞—à–∞ –∫–æ–º–∞–Ω–¥–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∞.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
                "‚Ä¢ –ü–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å\n"
                "‚Ä¢ –†–∞–∑–±–∏—Ç—å —Å–ª–æ–∂–Ω—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ —á–∞—Å—Ç–∏\n"
                "‚Ä¢ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç",
                reply_markup=get_main_keyboard()
            )
        except Exception as final_error:
            logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ: {final_error}")


# –ö–æ–º–∞–Ω–¥–∞ /help
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = (
        "ü§ñ –ü–æ–º–æ—â–Ω–∏–∫ –ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞ - –°–æ–∑–¥–∞–Ω –í–∞–¥–∏–º–æ–º (vadzim.by)\n\n"
        "üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n"
        "/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n"
        "/settings - –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è\n"
        "/about - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–æ–∑–¥–∞—Ç–µ–ª–µ\n\n"
        "üí° –ß—Ç–æ —è —É–º–µ—é:\n"
        "‚Ä¢ üîç –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥\n"
        "‚Ä¢ üêõ –ü–æ–º–æ–≥–∞—Ç—å —Å –æ—Ç–ª–∞–¥–∫–æ–π\n"
        "‚Ä¢ üìö –û–±—ä—è—Å–Ω—è—Ç—å –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è\n"
        "‚Ä¢ ‚ö° –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å\n"
        "‚Ä¢ üèóÔ∏è –î–∞–≤–∞—Ç—å —Å–æ–≤–µ—Ç—ã –ø–æ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ\n"
        "‚Ä¢ üìö –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é\n\n"
        "üöÄ –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∫–æ–¥!\n\n"
        "üëá –°–≤—è–∂–∏—Ç–µ—Å—å —Å —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ:"
    )
    await update.message.reply_text(
        help_text,
        reply_markup=get_main_keyboard()
    )


# –ö–æ–º–∞–Ω–¥–∞ /about
async def about_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    about_text = (
        "üë®‚Äçüíª –û —Å–æ–∑–¥–∞—Ç–µ–ª–µ:\n\n"
        "‚Ä¢ –ò–º—è: –í–∞–¥–∏–º (Vadzim)\n"
        "‚Ä¢ –°–∞–π—Ç: vadzim.by\n"
        "‚Ä¢ Telegram: @vadzim_belarus\n\n"
        "üõ† –°–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è:\n"
        "‚Ä¢ Full-stack —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞\n"
        "‚Ä¢ Python, JavaScript, Django, React\n"
        "‚Ä¢ –°–æ–∑–¥–∞–Ω–∏–µ Telegram –±–æ—Ç–æ–≤\n"
        "‚Ä¢ –í–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ API\n"
        "‚Ä¢ –ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è\n\n"
        "üåê –£—Å–ª—É–≥–∏:\n"
        "‚Ä¢ –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ —Å–∞–π—Ç–æ–≤ –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π\n"
        "‚Ä¢ –°–æ–∑–¥–∞–Ω–∏–µ Telegram –±–æ—Ç–æ–≤\n"
        "‚Ä¢ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∫–æ–¥–∞\n"
        "‚Ä¢ –ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏ –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é\n\n"
        "üöÄ –î–ª—è —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–∞ —Å–≤—è–∂–∏—Ç–µ—Å—å —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ:"
    )
    await update.message.reply_text(
        about_text,
        reply_markup=get_main_keyboard()
    )


# –ö–æ–º–∞–Ω–¥–∞ /stats - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_context = get_user_context(user_id)
    stats = user_db.get_user_stats(user_id)

    stats_text = (
        f"üìä –í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n"
        f"‚ùì –í—Å–µ–≥–æ –≤–æ–ø—Ä–æ—Å–æ–≤: {stats['total_questions']}\n"
        f"üéØ –£—Ä–æ–≤–µ–Ω—å: {user_context.skill_level}\n"
        f"‚≠ê –°—Ä–µ–¥–Ω—è—è –æ—Ü–µ–Ω–∫–∞: {sum(user_context.feedback_scores) / len(user_context.feedback_scores):.1f}/5\n" if user_context.feedback_scores else ""
                                                                                                                                                  f"üìÖ –° –Ω–∞–º–∏ —Å: {stats['member_since'][:10]}\n\n"
    )

    if stats['favorite_topics']:
        stats_text += "üî• –í–∞—à–∏ —Ç–µ–º—ã:\n"
        for topic in stats['favorite_topics'][-5:]:
            stats_text += f"‚Ä¢ {topic}\n"
        stats_text += "\n"

    if user_context.preferences['favorite_languages']:
        stats_text += "üíª –ò–∑—É—á–∞–µ–º—ã–µ —è–∑—ã–∫–∏:\n"
        for lang in user_context.preferences['favorite_languages']:
            stats_text += f"‚Ä¢ {lang}\n"
    else:
        stats_text += "üîç –ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –≤–∞—à–∏—Ö –∏–Ω—Ç–µ—Ä–µ—Å–∞—Ö\n\n"
        stats_text += "üí° –ó–∞–¥–∞–≤–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å—ã –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é, –∏ —è –±—É–¥—É –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –≤–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å!"

    await update.message.reply_text(
        stats_text,
        reply_markup=get_main_keyboard()
    )


# –ö–æ–º–∞–Ω–¥–∞ /admin - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –∞–¥–º–∏–Ω–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å–æ–∑–¥–∞—Ç–µ–ª—è)
async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –±–æ—Ç–∞
    if username != CREATOR_USERNAME[1:]:  # –£–±–∏—Ä–∞–µ–º @ –∏–∑ –Ω–∞—á–∞–ª–∞
        await update.message.reply_text("‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω")
        return

    total_users = user_db.get_all_users_count()
    active_users = len(user_db.get_active_users(7))

    admin_text = (
        f"üëë –ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å\n\n"
        f"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\n"
        f"üî• –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –Ω–µ–¥–µ–ª—é: {active_users}\n\n"
        f"üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏"
    )

    await update.message.reply_text(admin_text)


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"–û—à–∏–±–∫–∞: {context.error}")
    try:
        if update and update.message:
            await update.message.reply_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.",
                reply_markup=get_main_keyboard()
            )
    except:
        pass


# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def bot_runner():
    try:
        application = Application.builder().token(TELEGRAM_TOKEN).build()

        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("help", help_command))
        application.add_handler(CommandHandler("about", about_command))
        application.add_handler(CommandHandler("stats", stats_command))
        application.add_handler(CommandHandler("settings", settings_command))  # Added settings command
        application.add_handler(CommandHandler("admin", admin_command))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

        application.add_handler(CallbackQueryHandler(button_callback))

        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
        application.add_error_handler(error_handler)

        await application.initialize()
        await application.start()
        await application.updater.start_polling()

        logger.info("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! –°–æ–∑–¥–∞–Ω –í–∞–¥–∏–º–æ–º (vadzim.by)")
        print("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! –°–æ–∑–¥–∞–Ω –í–∞–¥–∏–º–æ–º (vadzim.by)")

        # –ü—Ä–æ—Å—Ç–æ–π —Ü–∏–∫–ª –æ–∂–∏–¥–∞–Ω–∏—è
        while True:
            await asyncio.sleep(1)

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞: {e}")
    finally:
        if 'application' in locals():
            if getattr(application, 'running', False):
                await application.stop()
            elif getattr(application, 'initialized', False):
                await application.shutdown()


async def health_handler(request):
    return web.Response(text="OK")


async def main_entry():
    bot_task = asyncio.create_task(bot_runner())

    app = web.Application()
    app.router.add_get("/", health_handler)
    app.router.add_get("/health", health_handler)

    runner = web.AppRunner(app)
    await runner.setup()
    port = int(os.getenv("PORT", "8000"))
    site = web.TCPSite(runner, host="0.0.0.0", port=port)

    try:
        await site.start()
        logger.info("Health check server running on port %s", port)
        await bot_task
    except asyncio.CancelledError:
        bot_task.cancel()
        raise
    except Exception:
        logger.exception("Critical error in bot loop")
        raise
    finally:
        if not bot_task.done():
            bot_task.cancel()
            try:
                await bot_task
            except asyncio.CancelledError:
                pass
        await runner.cleanup()

rate_limiter = RateLimiter()
response_cache = ResponseCache()

if __name__ == "__main__":
    asyncio.run(main_entry())




